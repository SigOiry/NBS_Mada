---
title: "Work about the bathymetry estimation of Sainte Marie Lagoon?"
author: "Simon Oiry"
format:
  html:
    css: styles.css
editor: visual
editor_options: 
  chunk_output_type: console
---
# Bathymetry in June 2025

Sentinel-2 images where downloaded from the [Copernicus DataSpace portal](https://browser.dataspace.copernicus.eu/). The images were acquired at Level-1C and atmospherically corrected using [ACOLITE](https://github.com/acolite/acolite), an atmospheric correction processor specifically adapted for aquatic applications and water-leaving reflectance retrieval [(Vanhellemont & Ruddick, 2016)](https://odnature.naturalsciences.be/downloads/publications/vanhellemontruddick_esa_lps2016_coastalapplications_final_header.pdf). The resulting subsurface remote-sensing reflectance was then used as input for bathymetric retrieval. Bathymetry was estimated using the SAMBUCA (Semi-Analytical Model for Bathymetry, Un-mixing and Concentration Assessment) inversion approach, which relies on a physics-based radiative transfer model linking subsurface reflectance to water depth through the attenuation of light in the water column and the contribution of bottom reflectance. In this framework, water depth is retrieved by minimizing the difference between modelled and measured subsurface reflectance spectra, while constraining the solution using known optical properties of the water and bottom substrates.

Since the present work focuses exclusively on bathymetry, only the depth parameter was retained from the SAMBUCA inversion, and no analysis of water-column constituents or benthic composition was performed. To ensure the reliability of the retrieved depths, only pixels corresponding to optically shallow waters, where the bottom signal contributes significantly to the surface reflectance, were retained using the substratum detectability index (SDI > 5). 
For each image, the depth retrieved by sambuca was then corrected from the water height at the moment of acquisition of the Sentinel-2 image. Water Height data was obtained from the [Marées Peche website](https://mareespeche.com/mg/madagascar/ambodifototra). The closest tidal reference station is Ambodifototra, located approximately 8 km from the Nosy Boahara Seaweed (NBS) facilities. All bathymetric depths were referenced to the Lowest Astronomical Tide (LAT), which represents the lowest theoretical sea level expected under average meteorological conditions and astronomical forcing only. Consequently, areas exhibiting positive elevation values correspond to intertidal zones that emerge during the strongest low tides, while negative values represent the water depth during lowest astronomical tides.
The bathymetry retrieved with sambuca is a Digital Surface Model (DSM), and not a Digital Elevation Model (DEM), meaning that pixel value represent height of canopy of the vegetation and not height of the ground [(More infos)](https://sigoiry.github.io/PhD/Chapter1/intro.html#fig-DSMDTM)



## Bathymetry in 2025

```{r leafletmapofBathy}
#| fig-cap: Map of the Bathymetry of the lagoon of Sainte Marie island. The bathymetry as been estimated from a Sentinel-2 image of the 
#| label: fig-Map_Bathy
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"
# Install once if needed:
# install.packages(c("terra", "sf", "leaflet", "leafem", "viridisLite"))

library(terra)
library(sf)
library(leaflet)
library(leafem)
library(viridisLite)
library(tidyverse)

## 1. Load your data ---------------------------------------------------------

# Original bathymetry: depth in metres (0–30 m)
bathy <- rast("Data/Bathymetry/Bathy_Lagoon_20250613_S2_Swampy.tif") %>% 
  project("EPSG:4326")

# Polygons: sf object with a column "ID"
polys <- st_read("Data/SHP/NBS_cadastre_Dec_2025.shp", quiet =T)

# Make sure both are in the same CRS
polys <- st_transform(polys, crs(bathy))


## 2. Create a DISPLAY-ONLY raster with values "squashed" to 0–3 m ----------

# This does NOT alter `bathy`. We create a new raster just for colors.
# Values <0 -> 0; values >3 -> 3; 0–3 unchanged.
bathy_display <- app(
  bathy,
  fun = function(x) {
    x[x < 0] <- 0
    x[x > 2] <- 2
    x
  }
)

# Colour palette focused on [0, 3]
pal_bathy <- colorNumeric(
  palette  = viridis(256),
  domain   = c(0, 2),
  na.color = "transparent"
)


## 3. Build the leaflet map --------------------------------------------------

m <- leaflet() |>
  # addTiles(group = "Base map") %>% 
  addProviderTiles(
    providers$Esri.WorldImagery,
    group = "Esri Satellite"
  ) %>% 
  
  # Bathymetry layer (display only, 0–3 m scale; deeper values = color of 3 m)
  addRasterImage(
    x       = bathy_display,
    colors  = pal_bathy,
    project = TRUE,
    # opacity = 0.8,
    group   = "Bathymetry"
  ) %>% 
  
  addLegend(
    pal       = pal_bathy,
    values    = c(0, 2),
    title     = "Depth (m)",
    position  = "bottomright",
    labFormat = labelFormat(suffix = " m")
  ) %>% 
  
  # Polygon layer with ID on hover
  addPolygons(
    data    = polys,
    group   = "Polygons",
    color   = "black",
    weight  = 1,
    fill    = "red",
    opacity  = 0.5,
    label   = ~as.character(ID),
    highlightOptions = highlightOptions(
      weight       = 3,
      color        = "red",
      bringToFront = TRUE
    ),
    labelOptions = labelOptions(
      direction = "auto",
      style     = list("font-weight" = "bold")
    )
  ) %>% 
  
  # Allow user to toggle both layers
  addLayersControl(
    baseGroups    = c("Esri Satellite"),
    overlayGroups = c("Bathymetry", "Polygons"),
    options       = layersControlOptions(collapsed = FALSE)
  )


## 4. Add real bathymetry value under cursor (0–30 m) -----------------------

# IMPORTANT: here we use the ORIGINAL `bathy` (0–30 m).
# So the query shows the true depth, even though colours are “compressed” to 0–3.
m <-  m %>%
  # wire up click‐popup: show value with 2 decimals
  addImageQuery(
    # map    = .,
    x = bathy$Bathy_Lagoon_20250613_S2_Swampy,
    project = TRUE,
    layerId= "Bathymetry",
    type   = "mousemove",
    digits = 2,
    prefix = ""
  ) 

m

```

## Bathymetry of Each Module

```{r gyraph plot}
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false


library(tidyverse)
library(terra)
library(sf)
library(ggiraph)
library(viridis)
library(mgcv)
library(tidyverse)
library(terra)
library(sf)
library(ggiraph)
library(viridis)
library(mgcv)

# --- INPUTS ---
# bathy : SpatRaster (0–30 m)
# polys : sf with column "ID"

# 0. Make valid + row index
polys_valid <- polys %>%
  st_make_valid() %>%
  mutate(poly_row = dplyr::row_number())

# 1. Centroid latitude per polygon
polys_cent <- polys_valid %>%
  st_centroid(of_largest_polygon = TRUE) %>%
  mutate(
    centroid_lat = st_coordinates(.)[, "Y"]
  ) %>%
  st_drop_geometry() %>%
  select(poly_row, ID, centroid_lat)

# 2. Extract raster values per polygon
df <- bathy %>%
  terra::extract(vect(polys_valid), df = TRUE) %>%
  as_tibble() %>%
  rename(
    poly_row = 1,
    bathy    = 2
  ) %>%
  left_join(polys_cent, by = "poly_row") %>%
  filter(!is.na(bathy))

# 3. Per-ID stats (median + SD)
df_stats <- df %>%
  group_by(ID, centroid_lat) %>%
  summarise(
    median_bathy = median(bathy, na.rm = TRUE),
    sd_bathy     = sd(bathy, na.rm = TRUE),
    .groups      = "drop"
  ) %>%
  mutate(
    ymin = median_bathy - sd_bathy,
    ymax = median_bathy + sd_bathy,
    tooltip = paste0(
      "ID: ", ID, "\n",
      "Latitude: ", round(centroid_lat, 4), "°\n",
      "Median depth: ", round(median_bathy, 2), " m\n",
      "SD: ±", round(sd_bathy, 2), " m"
    )
  )

# --- 4. GAM model & predictions (manual smooth + uncertainty) -------------

# Fit GAM: median bathymetry ~ smooth(latitude)
gam_fit <- gam(
  median_bathy ~ s(centroid_lat, k = 8),
  data   = df_stats,
  method = "REML"
)

# Prediction grid over latitude
new_lat <- tibble(
  centroid_lat = seq(
    min(df_stats$centroid_lat, na.rm = TRUE),
    max(df_stats$centroid_lat, na.rm = TRUE),
    length.out = 200
  )
)

pred <- predict(
  gam_fit,
  newdata = new_lat,
  se.fit  = TRUE
)

gam_df <- new_lat %>%
  mutate(
    fit   = pred$fit,
    se    = pred$se.fit,
    lower = fit - 1.96 * se,
    upper = fit + 1.96 * se
  )

# --- 5. Interactive plot --------------------------------------------------

p <- ggplot() +
  # SD whiskers (interactive)
  geom_errorbar_interactive(
    data = df_stats,
    aes(
      x     = centroid_lat,
      ymin  = ymin,
      ymax  = ymax,
      data_id = ID,
      tooltip = tooltip
    ),
    width = 0,
    alpha = 0.5
  ) +
  # Median points (interactive)
  geom_point_interactive(
    data = df_stats,
    aes(
      x       = centroid_lat,
      y       = median_bathy,
      color   = centroid_lat,
      data_id = ID,
      tooltip = tooltip
    ),
    size = 3
  ) +
  # GAM uncertainty ribbon (static)
  geom_ribbon(
    data = gam_df,
    aes(
      x    = centroid_lat,
      ymin = lower,
      ymax = upper
    ),
    inherit.aes = FALSE,
    alpha = 0.2
  ) +
  # GAM fitted line (static)
  geom_line(
    data = gam_df,
    aes(
      x = centroid_lat,
      y = fit
    ),
    inherit.aes = FALSE,
    linewidth = 1,
    color = "black"
  ) +
  scale_color_viridis_c(name = "Latitude") +
  labs(
    x = "Centroid latitude (°)",
    y = "Median bathymetry (m)",
    title = "Median bathymetry vs latitude with SD and GAM fit (95% CI)"
  ) + 
  scale_x_reverse()+
  theme_bw()

g <- girafe(
  ggobj      = p,
  width_svg  = 10,
  height_svg = 6,
  options = list(
    opts_hover(css = "stroke:black;stroke-width:2;"),
    opts_hover_inv(css = "opacity:0.3;"),
    opts_toolbar(saveaspng = TRUE)
  )
)

g




```

# Bathymetry time serie

Estimating the temporal variability of bathymetry can provide valuable insights into coastal and intertidal dynamics. Throughout this study, we assume that areas exhibiting the greatest bathymetric variability over time correspond to zones of strong hydrodynamic forcing, driven by tides, waves, and currents. Conversely, areas showing weak or negligible bathymetric change through time are interpreted as being subject to low hydrodynamic energy.
