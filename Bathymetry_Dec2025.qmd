---
title: "Work about the bathymetry estimation of Sainte Marie Lagoon?"
author: "Simon Oiry"
format:
  html:
    css: styles.css
editor: visual
editor_options: 
  chunk_output_type: console
---
# Bathymetry in June 2025

## Map of the Bathymetry

```{r leafletmapofBathy}
#| fig-cap: Map of the Bathymetry of the gulf od Sainte Marie
#| label: fig-Map_Bathy
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false
#| out-width: "95%"
# Install once if needed:
# install.packages(c("terra", "sf", "leaflet", "leafem", "viridisLite"))

library(terra)
library(sf)
library(leaflet)
library(leafem)
library(viridisLite)
library(tidyverse)

## 1. Load your data ---------------------------------------------------------

# Original bathymetry: depth in metres (0–30 m)
bathy <- rast("Data/Bathymetry/Bathy_Lagoon_20250613_S2_Swampy.tif") %>% 
  project("EPSG:4326")

# Polygons: sf object with a column "ID"
polys <- st_read("Data/SHP/NBS_cadastre_Dec_2025.shp", quiet =T)

# Make sure both are in the same CRS
polys <- st_transform(polys, crs(bathy))


## 2. Create a DISPLAY-ONLY raster with values "squashed" to 0–3 m ----------

# This does NOT alter `bathy`. We create a new raster just for colors.
# Values <0 -> 0; values >3 -> 3; 0–3 unchanged.
bathy_display <- app(
  bathy,
  fun = function(x) {
    x[x < 0] <- 0
    x[x > 2] <- 2
    x
  }
)

# Colour palette focused on [0, 3]
pal_bathy <- colorNumeric(
  palette  = viridis(256),
  domain   = c(0, 2),
  na.color = "transparent"
)


## 3. Build the leaflet map --------------------------------------------------

m <- leaflet() |>
  # addTiles(group = "Base map") %>% 
  addProviderTiles(
    providers$Esri.WorldImagery,
    group = "Esri Satellite"
  ) %>% 
  
  # Bathymetry layer (display only, 0–3 m scale; deeper values = color of 3 m)
  addRasterImage(
    x       = bathy_display,
    colors  = pal_bathy,
    project = TRUE,
    # opacity = 0.8,
    group   = "Bathymetry"
  ) %>% 
  
  addLegend(
    pal       = pal_bathy,
    values    = c(0, 2),
    title     = "Depth (m)",
    position  = "bottomright",
    labFormat = labelFormat(suffix = " m")
  ) %>% 
  
  # Polygon layer with ID on hover
  addPolygons(
    data    = polys,
    group   = "Polygons",
    color   = "black",
    weight  = 1,
    fill    = "red",
    opacity  = 0.5,
    label   = ~as.character(ID),
    highlightOptions = highlightOptions(
      weight       = 3,
      color        = "red",
      bringToFront = TRUE
    ),
    labelOptions = labelOptions(
      direction = "auto",
      style     = list("font-weight" = "bold")
    )
  ) %>% 
  
  # Allow user to toggle both layers
  addLayersControl(
    baseGroups    = c("Esri Satellite"),
    overlayGroups = c("Bathymetry", "Polygons"),
    options       = layersControlOptions(collapsed = FALSE)
  )


## 4. Add real bathymetry value under cursor (0–30 m) -----------------------

# IMPORTANT: here we use the ORIGINAL `bathy` (0–30 m).
# So the query shows the true depth, even though colours are “compressed” to 0–3.
m <-  m %>%
  # wire up click‐popup: show value with 2 decimals
  addImageQuery(
    # map    = .,
    x = bathy$Bathy_Lagoon_20250613_S2_Swampy,
    project = TRUE,
    layerId= "Bathymetry",
    type   = "mousemove",
    digits = 2,
    prefix = ""
  ) 

m

```

## Bathymetry of Each Module

```{r gyraph plot}
#| echo: false
#| error: false
#| message: false
#| eval: true
#| warning: false


library(tidyverse)
library(terra)
library(sf)
library(ggiraph)
library(viridis)
library(mgcv)
library(tidyverse)
library(terra)
library(sf)
library(ggiraph)
library(viridis)
library(mgcv)

# --- INPUTS ---
# bathy : SpatRaster (0–30 m)
# polys : sf with column "ID"

# 0. Make valid + row index
polys_valid <- polys %>%
  st_make_valid() %>%
  mutate(poly_row = dplyr::row_number())

# 1. Centroid latitude per polygon
polys_cent <- polys_valid %>%
  st_centroid(of_largest_polygon = TRUE) %>%
  mutate(
    centroid_lat = st_coordinates(.)[, "Y"]
  ) %>%
  st_drop_geometry() %>%
  select(poly_row, ID, centroid_lat)

# 2. Extract raster values per polygon
df <- bathy %>%
  terra::extract(vect(polys_valid), df = TRUE) %>%
  as_tibble() %>%
  rename(
    poly_row = 1,
    bathy    = 2
  ) %>%
  left_join(polys_cent, by = "poly_row") %>%
  filter(!is.na(bathy))

# 3. Per-ID stats (median + SD)
df_stats <- df %>%
  group_by(ID, centroid_lat) %>%
  summarise(
    median_bathy = median(bathy, na.rm = TRUE),
    sd_bathy     = sd(bathy, na.rm = TRUE),
    .groups      = "drop"
  ) %>%
  mutate(
    ymin = median_bathy - sd_bathy,
    ymax = median_bathy + sd_bathy,
    tooltip = paste0(
      "ID: ", ID, "\n",
      "Latitude: ", round(centroid_lat, 4), "°\n",
      "Median depth: ", round(median_bathy, 2), " m\n",
      "SD: ±", round(sd_bathy, 2), " m"
    )
  )

# --- 4. GAM model & predictions (manual smooth + uncertainty) -------------

# Fit GAM: median bathymetry ~ smooth(latitude)
gam_fit <- gam(
  median_bathy ~ s(centroid_lat, k = 8),
  data   = df_stats,
  method = "REML"
)

# Prediction grid over latitude
new_lat <- tibble(
  centroid_lat = seq(
    min(df_stats$centroid_lat, na.rm = TRUE),
    max(df_stats$centroid_lat, na.rm = TRUE),
    length.out = 200
  )
)

pred <- predict(
  gam_fit,
  newdata = new_lat,
  se.fit  = TRUE
)

gam_df <- new_lat %>%
  mutate(
    fit   = pred$fit,
    se    = pred$se.fit,
    lower = fit - 1.96 * se,
    upper = fit + 1.96 * se
  )

# --- 5. Interactive plot --------------------------------------------------

p <- ggplot() +
  # SD whiskers (interactive)
  geom_errorbar_interactive(
    data = df_stats,
    aes(
      x     = centroid_lat,
      ymin  = ymin,
      ymax  = ymax,
      data_id = ID,
      tooltip = tooltip
    ),
    width = 0,
    alpha = 0.5
  ) +
  # Median points (interactive)
  geom_point_interactive(
    data = df_stats,
    aes(
      x       = centroid_lat,
      y       = median_bathy,
      color   = centroid_lat,
      data_id = ID,
      tooltip = tooltip
    ),
    size = 3
  ) +
  # GAM uncertainty ribbon (static)
  geom_ribbon(
    data = gam_df,
    aes(
      x    = centroid_lat,
      ymin = lower,
      ymax = upper
    ),
    inherit.aes = FALSE,
    alpha = 0.2
  ) +
  # GAM fitted line (static)
  geom_line(
    data = gam_df,
    aes(
      x = centroid_lat,
      y = fit
    ),
    inherit.aes = FALSE,
    linewidth = 1,
    color = "black"
  ) +
  scale_color_viridis_c(name = "Latitude") +
  labs(
    x = "Centroid latitude (°)",
    y = "Median bathymetry (m)",
    title = "Median bathymetry vs latitude with SD and GAM fit (95% CI)"
  ) + 
  scale_x_reverse()+
  theme_bw()

g <- girafe(
  ggobj      = p,
  width_svg  = 10,
  height_svg = 6,
  options = list(
    opts_hover(css = "stroke:black;stroke-width:2;"),
    opts_hover_inv(css = "opacity:0.3;"),
    opts_toolbar(saveaspng = TRUE)
  )
)

g




```

# Bathymetry time serie

Estimating the temporal variability of bathymetry can provide valuable insights into coastal and intertidal dynamics. Throughout this study, we assume that areas exhibiting the greatest bathymetric variability over time correspond to zones of strong hydrodynamic forcing, driven by tides, waves, and currents. Conversely, areas showing weak or negligible bathymetric change through time are interpreted as being subject to low hydrodynamic energy.

